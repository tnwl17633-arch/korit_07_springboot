# MVC Pattern
-정의 : 애플리케이션의 구조를 모델, 뷰, 컨트롤러라는 세 부분으로 분리하여 개발하는 방식

## MVC 패턴이란 무엇인가
사용자 인터페이스를 갖춘 애플리케이션을 구조화하는 소프트웨어 디자인 패턴.
이는 비지니스 로직(데이터 처리), 사용자 인터페이스(화면 표시), 그리고 이들을 연결하는 제어 로직을 명확하게 분리하는 것을 목표로 합니다.
-MVC의 구성 요소
  -Model
    -역할 : 데이터와 비지니스 로직을 담당. 애플리케이션이 '무엇을'하는지에 대한 핵심적인 부분. 데이터의 저장, 처리, 조회, 변경 등의 작업을 수행하며, 사용자에게 보여줄 데이터 자체를 담고 있음.
    -Springboot 상에서의 형태 : Servicee 클래스, Repository(DAO) 클래스, 혹은 데이터 객체(DTO 또는 Entity) 등이 해당함.
-View
  역할 : 사용자에게 _데이터를 시각적으로 보여주는 역할_ . 사용자의 입력(클릭, 폼 제출 등)을 받고, 그 결과를 화면에 렌더링함.
  '어떻게'보여줄지를 담당(그러면 저희가 HTML / CSS 부분이 떠오르죠).
  -SpringBoot 상에서의 형태 : HTML / CSS / JS를 통해 구성된 페이지들이며, SpringBoot에서는 주로 Thymeleaf, JSP(Java Server Page) 등의 템플릿 엔진을 사용하거나, REST API의 경우에는 JSON/XML 등의 데이터 형식으로 응답합니다. 근데 우리는 React로 연결할겁니다.
-Controller
  -역할 : 사용자의 요청을 받아 처리하고, Model과 View르 연결하는 중재자 역할. 사용자가 '무엇을 할지'에 대한 요청을 분석하고, Model에게 필요한 작업을 지시한 후, 결과를 바탕으로 적절한 View를 선택하여 사용자에게 응답.
  -SpringBoot 상에서의 형태 : `@Controller, @RestController` 애너테이션이 붙은 클래스.
  `@RequestMapping` 등의 애너테이션으로 특정 URL 요청을 처리하는 메서드를 정의.

## Spring MVC의 동작 원리(요청 처리 흐름)
SpringBoot는 내부적으로 Spring MVC 프레임워크를 사용하여 MVC 패턴을 구현. 모든 요청을 처리하는 중앙 집중식 프론트 컨트롤러(Front Controller)방식이 핵심.

-DispatcherServlet(디스패치 서블릿) - Spring MVC의 Core
  -웹 애플리케이션으로 돌아오는 모든 HTTP 요청을 가장 먼저 받아서 처리한느 프론트 컨트롤러 역할. SpringBoot는 '내장된 웹 서버(보통은 아파치 톰캣입니다)를 사용하며, 별도의 복잡한 설정 없이 DispatcherServlet이 자동 설정됩니다(Spring으로 개발하면 이 서버 설정도 개발자가 해야 합니다).

-요청 처리의 단계
  -사용자가 웹 브라우저에서 특정 URL을 입력하거나 버튼을 클릭할 때(HTTP 요청 발생)부터 화면에 결과가 표시될 때 까지의 과정을 상세 설명합니다.
  1. 요청 수신(Request Reception) : 사용자의 요청(예시 : `GET / users / 1`)이 `DispatcherServlet`으로 전달.
  2. 핸들러 매핑(Handler Mapping) : 
  `DispatcherServlet`은 `HandlerMapping`에게 요청 URL을 처리할 적절한 Controller를 찾아달라고 요청. 
  -`HandlerMapping`은 주로 `@Controller` 클래스의 `@RequestMapping` 애너테이션을 확인해서 요청을 처리할 특정 메서드를 찾게 됨.
  3. Controller 실행 :
  - `DispatcherServlet` 은 찾은 Controller의 메서드를 `HandlerAdapter`를 통해 실행.
  -Controller는 요청을 분석하여 (필요한 경우에) Service/Respository(Model) 계층에 데이터 처리(비지니스 로직)를 요청.
  -예를 들어, 사용자 정보를 조회하는 요청이라면 Model 계층에서 데이터베이스로부터 해당 정보를 가져오게 되겠네요(그런데 비밀번호는 안보여주겠네요 - Entity의 field를 편집한 버전을 전달해주겠다고 볼 수 있습니다).
  4. ModelView 반환
    -Controller의 _처리 결과를 담은 Model 데이터와 View의 논리적 이름을 포함하는_ ModelAndView 객체(또느 View 이름만, 또는 Model데이터만)를 `DispatcherServlet`에게 return.
  5. View 이름 해석(View Resolution) :
    -`DispatcherServlet`은 `ViewResolver`에게 View의 논리적인 이름(예를 들어 "user-detail")을 전달하여 실제 렌더링을 담당할 View 객체를 찾도록 요청.
  6. View 렌더링 및 응답(View Rendoring & Response) :
    -`DispatcherServlet`는 최종적으로 View 객체에게 Model 데이터를 전달하고 렌더링을 요청합니다.
    -View는 Model 데이터를 사용하여 최종적인 HTML 응답 페이지를 생성하고, 이 응답은 `DispatcherServlet`을 거쳐 사용자(브라우저)에게 전송됩니다.

    -쉽게 설명하면 `GET users/1` 이면 DB 상에서의 user_id가 1인 애의 데이터를 이용하여 HTML 문서를 만들고, 2라면 user_id가 2인 애의 데이터를 활용하여 HTML 문서를 만들어서 브라우저로 보여준다고 보시면 되겠습니다.

    ## SpringBoot 3.5.6에서의 MVC 특징 및 구현 예시
    SpringBoot에서는 Spring MVC를 자동으로 처리해주기 때문에 개발자는 핵심 로직에만 집중할 수 있습니다(비지니스 로직만 신경쓰고 서버 설정 그런건 좀 안해도 된다 그런 뜻입니다). 3.xx.xx 버전은 Java 17을 기반으로 하고, 설정 간소화와 편의성이 더 늘었습니다.

    -Controller 구현 예시
    ```Java


  @Controller   // 해당 클래스가 Controller임을 선언
  public class UserController {
    private final UserService userService; // Model 계층과의 상호작용을 위한 Service를 주입(Injection)

    // 생성자 주입
  public UserController(UserService userService) {
    this.userService = userService;
    }  

    // GET 요청으로 /users/123
    @GetMapping("/userse/{userId}")
    public String getUserDetail(@PathVariable Long userId, Model model) {
      // 1. Controller는 Model(Service)에 데이터 처리를 요청
      User user = userService.findUserById(userId);
      // 2. Controller는 Model 데이터를 View에 전달하기 위해 Model 객체를 담음
      model.addAttribute("user", user);
      model.addAttribute("pageTitle", "사용자 상세 정보");

      // 3. Controller는 View의 논리적 이름을 return
      // : (ViewResolver가 'user-detail'에 해당하는 템플릿을 찾음)
      return "user-detail";
    }
  }
  ```
  이상의 코드는 Thymeleaf를 활용하여 SpringBoot와 HTML 문서를 연결하는 방식으로 저희가 받은 교재 중에 하나인 SpringBoot로 백엔드 개발자되기 책에도 동일한 방식의 코드 구현을 하고 있습니다.

  -Model(Service 계층) 구현 예시
  Controller의 요청을 받아서 설계 비지니스 로직을 처리하는 영역입니다. -저희가 Java의 제어문을 배운 이유가 여기 부분에 특히 많이 들어갑니다.
  ```java
  @Service    // 해당 클래스가 Service(Model)임을 명시
  public class UserService {
    private final UserRepository userRepository;

    public userService(UserRepository userRepository) {
      this.userRepository = userRepository;
    }

    public User findUserById(Long id) {
      // UserRepository에서 담겨있는 DB를 조회해서 Java에서 쓸 수 있도록 해야겠네요.
      User user = userRepository.findById(id);
      if(id == 123L) {
        return user;
      }
      return null;
    }
  }
  ```
  - 그 다음은 View 파트를 작성해야 하는데, Thymeleaf로 쓰는 예시를 굳이 보여드릴 필요는 없을 것 같아서 그냥 지나가겠습니다. 저희는 React로 작성할겁니다. 혹시나 Thymeleaf 프레임워크의 예시가 궁금하면 이상의 교재를 확인하면 됩니다.

  ### MVC 패턴 사용의 장점
  1. 관심사 분리(Seperation of Concerns) : 
    -데이터 처리(Mdoel), 화면 표시(View), 요청 처리(Controller)가 명확하게 분리되어 있어,
    각 부분을 독립적으로 개발하고 수정할 수 있음.
      -보여주는 부분이 잘못됐다 -> View 수정
      -DB에서 가져오지를 못한다 -> Repository or Service 수정
      -요청 앤드포인트가 잘못됐다 -> Controller 수정 등
  2. 높은 재사용성 :
    동일한 Model(비지니스 로직)을 사용하여 여러 View(웹페이지, 모바일 앱, REST API 등)를 만들 수 있음(대충 사이즈 줄여가지고 모바일 버전 웹 페이지를 만든다든지, 회원가입 창을 재활용해서 로그인 창으로 쓴다든지 등입니다).
  3. 유지 보수의 용이성:
    -화면 디자인이 변경되어도 Controller나 Model 코드는 거의 수정할 필요가 없습니다.
    반대로, 비지니스 로직이 바뀌어도 View에 미치는 영향이 최소화됩니다.
    -지금 카카오톡 생각해보시면 View가 바뀌었다고 볼 수 있겠죠. 하지만 DB에 저희 프로필 사진들은 다 있을겁니다. 가장 최근 id를 기준으로 프로필 사진에, 나머지 사진들은 커버 사진에 집어넣어놨던 걸 인스타그램식으로 고쳐놨다고 보면 되겠네요. 즉, DB에 있는 다른 부분들의 코드 수정이 막 엄청나게 일어나지는 않았을거란 겁니다.
  4. 테스트 용이성 :
    -각 구성 요소가 독립적이기 때문에 단위 테스트를 쉽게 작성하고 수행할 수 있습니다.(GET 요청만 확인한다든지 등으로 저희가 금요일에 이미 작성해봤습니다) 특히 Controller와 Model의 비지니스 로직은 View와 독립적으로 테스트 가능합니다.(postman으로, HeidSQL로 CRUD 테스트를 마무리 지었습니다. 화면은 아예 없는데도요.)
  5. 병렬 개발 가능:
    프론트엔드 개발자(View)와 백엔드 개발자(Controller, Model)가 서로의 작업에 크게 영향을 주지 않으면서 동시 개발이 가능해 속도가 향상됩니다.

  ## 요약
  1. MVC는 Model / View / Controller로 _코드를 분리_ 하는 _디자인 패턴_ 입니다.
  2. `DispatcherServlet` 이라는 프론트 컨트롤러를 통하여 요청을 처리합니다.
  3. Controller는 요청을 받고 Model을 호출하여 View를 선택하는 중재자 역할을 합니다.
    -View에서 요청(Request) -> Controller 내부의 코드에서 Service 호출 -> Service가 Repository를 호출하여 DB 관련 정보 습득 후 데이터 처리 -> Controller로 보내주면 ->
    Controller가 적절한 .html 문서를 응답(Response). / 저희는 ResponseEntity 쓸겁니다.
  4. Model은 비지니스 로직과 데이터를 담당(Entity - Respository - Service)


  # Spring Initializer를 통해서 cardatabase_4를 만들겁니다.
  https://start.spring.io

  # 프로젝트 만든 후에 실행 여부를 따졌을 때 실행이 되는 시점을 기준으로 합니다.
  1. Car / CarRepository를 만들었습니다.
    -그런데 CarRepository 부분에서 JpaRepository를 상속받으려고 하니 검색이 안됐습니다.
  `implementation 'org.springframework.boot:spring-boot-starter-data-jpa'`가 없어서.
  -그래서 추가해주고 코끼리 눌렀습니다.
  -여전히 오류가 발생합니다 -> Car의 field로 Owner가 있는데 현재 Owner Entity가 없어서.

  2. Owner / OwnerRepository를 생성했습니다.
    -그리고 실행시키려고 해보니까 실행 안됩니다.
    -왜?
    -application.properties에 관련 설정들 아무 것도 안넣어서.
    -build.gradle에 mariadb 관련 의존성 추가 안해서.
    -이상의 설정들을 마무리 짓고 스프링부트 애플리케이션을 실행시켰을 때의 결과값은?
      -HeidSQL 켜서 `SELECT * FROM car;` 했을 떄 row=0인 테이블이 생성 완료되어있어야 함.
      -하지만 Controller 파트를 작성하지 않았기 때문에 HeidiSQL 에서는 데이터를 확인 및 추가가 가능하지만 postman을 통해서는 불가능하다는 것도 확인됐습니다.

  3. 이상의 과정에서 생긴 문제를 보아 저희는 MVC 패턴을 만들어야 postman에서 CRUD를 할 수 있을 것 같습니다. 그러면 Model 파트에서 만든 Entity와 Repository를 제외하고 Service파트도 만들어야하고, Controller 파트에 해당하는 Controller 클래스도 만들어야겠네요.
    -루트 프로젝트 패키지에서 service 패키지를 생성하고 -> CarService를 생성하겠습니다.

  4. 그러면 이제 페이지를 보여줄 수 있도록해야하는데, 저희는 이걸 React와 연결할거니까 View와 연결하는건 아니고 ResponseEntity와 연결하기 위한 CarController를 작성할겁니다.
    - 루프 프로젝트 패키지에서 web을 생성 -> CarController를 만들겠습니다.

```java
package com.example.cardatabase_4.service;

import com.example.cardatabase_4.domain.Car;
import com.example.cardatabase_4. domain.CarRepository;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;

import java.util.List;

@Service
public class CarService {
    private final CarRepository carRepository;


    public CarService(CarRepository carRepository) {
        this.carRepository = carRepository;
    }

    //모든 자동차 목록을 조회한다고 가정하겠습니다.
    public List<Car> getCars() {
        return carRepository.findAll();
    }

    // 새로운 자동차 저장
    public Car addCar(Car car) {
        return carRepository.save(car);
    }
}
```


# .map() 
함수형 프로그래밍의 핵심 개념 중 하나로, Collection이나 컨테이너 객체 내부의 _각 요소를 변환_ 하여 새로운 컬렉션이나 컨테이너를 생성하는 데 사용.

## .map()의 전반적 정의
-목적 : 컨테이너 객체(예:Stream, Optional) 내부의 값을 다른 타입 또는 형태의 값으로 변환하여 새로운 컨테이너를 반환.
- 각 element에 적용될 변환 함수(Function)을 argument로 받습니다.-> 그래서 람다식이 필수적
-원본 데이터는 변경하지 않고 변환된 element를 담는 _새로운 객체_ 를 만들어냅니다.
(함수형 프로그래밍의 특징).

## .map()이 존재하는 주요 자료형(Java 기준)
1. `Optional<T>` : 값이 있을 수도 있고 없을 수도 있는 _단일 컨테이너_
  -역할 : 값이 존재할 경우에만 그 값을 변환하고, 그 결과를 다시 `Optional`로 감싸서 return. 값이 비어있는 경우에는 비어있는 Optional을 return
  -예시 : `Optional<User>`를 `Optional<String>`으로 변환할 때 사용 등

2. `Stream<T>` : 데이터소스(컬렉션, 배열 등)에서 element를 처리하기 위한 파이프라인을 구축하기 위해서 사용
  -역할 : Stream 내의 모든 element에 대하여 argument로 들어온 변환 함수(람다식 형태)를 적용하여, 변환된 element를 담는 새로운 스트림을 생성.
  -예시 : `Stream<String>`(단어 목록)을 `Stream<Integer>`(각 단어의 길이)로 변환

3. Collection : List, Set 등의 자료 구조
  -역할 : 대부분의 객체 지향 언어에서 컬렉션이 자체적으로 .map()을 지원하는데, Java에서는 컬렉션을 직접 변환하기 위해 Stream을 거쳐야합니다.

## 예시 
1. Stream에서 사용하기(가장 흔함)
```java
public class StreamMapExample {
public static void main(String[] args) {
  List<Integer> numbers = Arrays.asList(1,2,3,4,5);


  // 1. stream 형태로 바꾸는 작업
  List<Integer> squredNumbers = numbers.stream()
  // 2. .map()으로 각 element(1,2,3,4,5)에 n * n을 하도록 내부에 람다식 적용
  .map(n-> n*n)
  // 3. 현재는 stream이니까 다시 List로 바꿔줘야 합니다.
  .collect(Collectors.toList());

  System.out.println(SquaredNumbers); // 결과값 [1,4,9,16,25]
  System.out.println(numbers); // 결과값 : [1,2,3,4,5]
 }
}
```


2. Optional에서 사용하기(값의 안전한 접근 및 변환)
예를 들어 User 객체에서 이메일 주소만 가지고 오는데, User 객체가 존재할 떄만 동작하도록 보장
```java
Class User{
  private String email;
  public User(String email) {this.email = email; }
  public String getEmail() { return email; }
}

public class OptionalMapExample {
  //사용자를 찾지 못했을 때는 비어있는 Optional을 반환하는 메서드 정의할겁니다
  //(우리가 이런걸 안쓴 이유는 extends JpaRepository 때문이라는 거 잊지 마세요)
  public static Optional<User> findUser(boolean found) [
    // return에 삼항연산자 쓸겁니다.
    return found ? Optional.of(new User("kim1@text.com"))   : Optional.empty();
}

public static void main(String[] args) {
  // 1. User 객체가 있는 경우를 예시로.
  String emailFound = findUser(false)
  // User 객체가 있으면 getEmail() 메서드를 호출하여 String으로 변환할 수 있도록 .map() 적용
  .map(User:: getEmail)
  // 만약에 Optional<String>이 비어있으면 "N/A"를 반환하도록 작성
  .orElse("N/A");

  System.out.println("E-mail : " + emailFound); // 결과값 : kim1@test.com
  
  String emailNotFound = findUser(false)
  // User 객체가 있으면 getEmail() 메서드를 호출하여 String으로 변환할 수 있도록 .map() 적용
  .map(User:: getEmail)
  // 만약에 Optional<String>이 비어있으면 "N/A"를 반환하도록 작성
  .orElse("N/A");

  System.out.println("E-mail : "+ emailFound); // 결과값 : E-mail : N/A

  }
}
```

# deleteCar() 부분 작성중입니다.
다 끝낸 상황에서 SprinBootApplication을 실행시킨 후에 저희는 create-drop 설정 때문에 DB에 아무런 값이 없습니다.

1. POST 요청을 통해 새로운 Car 객체를 집어넣습니다.
2. GET 요청을 통해 Car 객체가 제대로 DB에 들어갔는지 확인합니다.
3. SELECT 요청을 통해서 Car 객체를 삭제하고 204 No Content를 postman에 띄우면 됩니다.

20250929 15:39 기준으로 Car Entity를 기준으로 한 CRUD 전체를 구현했습니다. DBMS 및 postman에서의 확인도 끝남.
여러분은 Owner 기준으로 전체 다 만들면 됨

Service/Controller에 구현할 목록-> Owner 전체 조회 / id 별 조회 / Owner 객체 추가 / Owner 객체 삭제 / Owner 객체 수정이 되겠음.

오늘 중으로 마무리 지으시오.



  


