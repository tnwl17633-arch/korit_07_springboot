1. intellij installationn - 이미 완료
2. gradle

## gradle의 이해
-소프트웨어 개발 프로세스를 간소화 및 통합하는 빌드 자동화 툴이며, _프로젝트 의존성을 관리하고 빌드 프로세스를 처리_한ㄷ다.
-Springboot와 함께 메이븐(Maven)이란느 다른 프로젝트 관리 도굳를 쓸 수도 있지만 가시성이 좋은 gradle을 선택했습니다.
-gradle의 구성은 프로젝트의 build.gradle 파일에서 수행. 이 파일은 프로젝트의 특정 요구사항에 맞게 사용자가 지정 가능하며 소프트웨어 빌드,
테스트 및 배포와 같은 작업을 자동하는 데 이용 가능.
-이상의 파일은 일반적으로 프로젝트 컴파일에 필요한 외부 라이브러리 및 프레임워크 등 프로젝트의 의존성에 대한 정보를 포함(저희가 Java를 할 때는 Lombok설치가
이루어졌었습니다.)
-build.gradle 파일을 작성할 떄 Kotlin또는Groovy 프로그래밍 언어를 사용할 수 있는데 저희는 Grooby로 선택했었습니다.

### 일반적인 build.gradle 내부의 항목
1. 플러그인(plugins) : 플러그인 블록은 프로젝트에서 쓰이는 gradle 플러그인을 정의하는 곳이며 저희는 이제 롬복 뿐만 아니라 springboot 버전도 명시할겁니다.

2. 리포지토리(repository) : 의존성을 해결하는 데 쓰이는 의존성 리포지토리를 정의. 여기서는 gradle이 의존성을 가져오기 위해 Maven Central 리포지토리를 사용할 예정입니다.

3. 의존성(dependencies) : 프로젝트에서 이용되는 _의존성_ 지정(의존성 오늘 수업 예정)

4. 태스크(tasks) : 테스크 등의 빌드 프로세스의 일부인 태스크를 정의.

### 스프링 이니셜라이저 활용
https://start.spring.io

1. Spring Web : Web 개발 관련 설정을 default로 가지고 있는 의존성.
2. Spring Boot Dev Tolls : 자동 재시작 기능을 제공하는 의존성으로, 변경 내용을 저장할 때마다 애플리케이션이 자동 재시작되므로 덜 귀찮습니다.

```java
package com.example.cardatabase;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication {

    public static void main(String[] args) { SpringApplication.run
            (CardatabaseApplication.class, args);}
}

```
이상의 main에서 처음 보는 애너테이션인 `@SpringBootApplication`이 있습니다.
여러 애너테이션의 조합으로 이루어진 것으로 필요한 부분들만 정리하도록 하겠습니다.
1. @EnableAutoConfiguration
    -스프링부트의 자동 구성을 활성화. 프로젝트가 의존성에 따라 자동으로 구성되는데, 예를 들어 spring-boot-starteer-web 의존성이 있는 경우 스프링 부트는
사용자가 웹 애플리케이션을 개발 중이라고 가정하고, 그에 따라 애플리케이션을 알아서 설정해줍니다.
2. @ComponentScan
    -스프링 부트 컴포넌트 검색으로 애플리케이션의 모든 컴포넌트를 찾을 수 있도록 함.
3. @Configuration
    - Bean 정의를 제공한느 소스로 쓸 수 있는 클래스를 지정.

### Spring Boot Dev Tools
-이상의 의존성은 애플리케이션 개발 프로세스를 간략화해주는 의존성으로, 가장 중요한 것 중 하나는 클래스 경로의 파일이 수정될 때마다 스프링 부트 애플리케이션을 자동으로
재시작해준다는 겁니다.

### Logging / Problem-Solution
-저희가 한국인이라서 콘솔에 딸려있는 영어 보는걸 끔찍하게 싫어하기는 하는데 로깅은 애플리케이션의 흐름을 모니터링하는 데 이용할 수 있고, 프로그램 코드의 예기치 않은 오류를
포착할 수 있는 좋은 방법입니다. Spring Boot Starter 패키지에는 별도의 구성 없이 로깅에 이용할 수 있는 LogBack이 있습니다.
-로그백은 SLF4J(Simple LOgging Facade For Java)를 기본 인터페이스로 사용합니다.

package com.example.cardatabase;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CardatabaseApplication {
private static final Logger logger = LoggerFactory.getLogger(
CardatabaseApplication.class
);


	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
		logger.info("Application Started ! / 애플리케이션이 실행되었습니다.");
	}

}
```
```
이상에서 이제 주의할 점은 아가 전에 보신 것처럼 logger 하나 import 하려고 할 때도 동일한 이름을 지닌 클래스 / 인터페이스가 많다는 점입니다.
그래서 앞으로 수업을 할 때 웬만하면 import 경로도 같이 알려드리게 될텐데, 혹시나 강사가 실행한 결과값과 다르거나 아니면 아예 빨간 줄 뜨는 경우에는
import 경로도 한 번 확인해줘야 함.

logger.info() 메서드는 로그 메시지를 콘솔에 출력함.

그리고 로깅 수준에는 TRACE / DEGUG / INFO / WARN / ERROR / FATAL / OFF 7가지로 나뉩니다.
이를 application.propereties에서 설정할 수 있습니다. 이는 저희가 Java할 때는 한 번도 본 적 없었던 resources 폴더 내에 있습니다.
`logging.level.root-DEBUG`로 작성한다면, 로그 수준이 DEBUG 및 그 이상(즉, DEBUG / INFO / WARN / ERROR) 에 해당하는 로그 메시지를 볼 수 있습니다.

그리고 만약에 다시 재시작하게 된다면 TRACE 관련 메시지는 표시되지 않습니다. 별도로 지정하지 않은 default 로깅 수준은 INFO에 해당합니다.

근데 이거 제가 수업해보니까 죽었다 깨어나도 콘솔을 안보기 때문에 나중에 사용되는지 여부를 물어봤을 떄 수강생분들이 잘 안쓰긴 했습니다...

그리고 스프링부트의 기본 port 번호는 8080에 해당합니다.
수강생분들이 너무 너무너무 많이 실수하는 것 중 하나는 코드를 수정했을 때 바로 실행 버튼을 눌러서 port number가 겹쳐서 실행이 안되는 경우입니다.
그래서 제 수업 중에서는 코드 수정 후에 종료를 누르는 것을 일단 통제하도록 하겠습니다.

그럼 저희 현재 port 구성을 확인해보면
Springboot : 8080
MariaDB : 3310
으로 기억해두시면 됩니다.

# 의존성 주입(Dependency Injection)
## 정의
-다른 객체에 의존하는 객체를 만들 수 있는 소프트웨어 개발 기법.
-클래스 간의 상호작용을 도우면서 동시에 클래스를 독립적으로 유지
-의존성 주입의 세 가지 클래스 유형
1. 서비스(Service) : 클라이언트가 이용할 수 있는 클래스(의존성)
2. 클라이언트(Client) : 의존성을 이용하는 클래스
3. 주입기(Injector) : 의존성(서비스)을 의존 클래스(클라이언트)에 전달.

의존성 주입을 통해 클래스를 느슨하게 연결하는 것이 가능합니다. 즉, 클라이언트 의존성의 생성이 클라이언트의 작동과 분리되어 단위 테스트가 더 쉬워집니다.

예를 들어 일반적인 형태의 객체 생성 과정을 보겠습니다.

```java
public class Car{
    // 필드 정의
    private Owner owner;
    // 생성자
    public Car() { 
        owner = new Owner();
    }
}
```
이상의 코드는 클라이언트 클래스인 Car가 서비스 클래스(Owner)의 객체를 생성하기 때문에 의존성 주입이 없습니다.

그리고 또 이하의 코드를 확인하겠습니다.
```java
public class Car{
    private Owner owner; 
    public Car(Owner owner) {
        this.owner = owner;
    }
}

public class CarMain{
    public static void main(String[] args) {
        Car car1 = new Car(new Owner());
        // 혹은
        Owner owner2 = new Owner();
        Car car2 = new Car(owner2);
    }
}
```
이상의 코드는 서비스 객체가 클라이언트 클래스에서 직접 생성되지 않습니다. 대신 클래스 생성자에서 매개변수로 전달되는 예시입니다.

여기서 Client class가 Car고 의존성에 해당하는 것이 Owner라는 점에 유의하시고 해석하시기 바랍니다.

또한 서비스 클래스는 추상 클래스일 수도 있습니다. 이 경우 클라이언트 클래스에서 해당 클래스의 어떤 구현이든 이용할 수 있고, 테스트 중에는
Mock을 이용할 수도 있습니다.

의존성 주입에도 마찬가지로 유형이 있습니다.
## 의존성 주입 유형
1. 생성자(Constructor) 주입 : 의존성이 클라이언트 클래스 생성자에게 전달되는 방식. 생성자 주입의 예시는 앞의 Car 코드에서 확인 가능합니다.
생성자 주입은 필수 의존성에 이용하는 것이 좋습니다. 모든 의존성은 클래스 생성자를 이용하여 제공되며 필수 의존성 없이는 객체를 생성할 수 없습니다(즉 매개변수 생성자를
이용하라는 의미입니다.)

2. 세터(Setter)주입 : 의존성이 세터를 통해 제공되는 방식입니다. 이하의 코드를 확인하겠습니다.
```java
public class Car {
    private Owner onwer;

    public void setOwner(Owner owner) {
        this.owner = owner;
    }
}
```
이상의 세터 주입은 아무런 의존성이 없더라도 객체를 생성할 수 있기 때문에 더 유연합니다. 이 접근 방식은 선택적 의존성을 허용해줍니다.

의존성 주입은 코드의 의존성을 줄이고 코드를 _재사용하기 쉽게_ 만들어줍니다.
이제 스프링부트 상에서의 의존성 주입 부분을 학습할겁니다.

## 스프링 부트에서의 의존성 주입 이용
스프링 프레임워크에서 의존성 주입은 스프링 ApplicationContext를 통해 이루어집니다. 이는 객체(빈 bean)와 객체의 의존성을 생성하고 관리하는 역할.

스프링 부트 애플리케이션 클래스를 검색하여 특정 애너테이션(@Service / @Repository / @Controller 등)이 있는 클래스를 스프링 빈으로 등록합니다. 의존성을
주입하면 이렇나 빈을 주입할 수 있습니다.

아까 배운 생성자 주입 / 세터 주입 / 필드 주입 방식을 스프링부트 버전으로 풀어서 쓰겠습니다.

1. 생성자 주입
    -생성자를 통해 의존성을 주입. 이 방법은 객체가 생성될 때 필요한 모든 의존성을 반드시 이용하게 하므로 가장 권장되는 방법. 가장 보편적인 상황은 
특정 작업을 위해 DB에 대한 접근이 필요한 경우입니다. 스프링부트에서는 이를 위해 repository 클래스를 이용합니다.
```java
public class Car {
    private final CarRepository carRepository;

    public Car(CarRepository carRepository) {
        this.carRepository = carRepository;
    }
    // DB 상에서 CarRepository에 있는 모든 자동차 목록을 가져옴.
    carRepository.findAll(); // SELECT * FROM car;
    carRepository.findOwner(); // SELECT owner FROM car;
}
```
여기서 중요한 것 중 하나는 .findAll();이라는 메서드가 메서드명이 고정되어있다는 점입니다.

근데 클래스에 생성자가 여러 개 있는 경우 `@AutoWired` 애너테이션을 이용하여 의존성 주입에 이용되는 생성자를 정의해야 합니다.

```java
public class Car {
    private final CarRepository carRepository;

    // 의존성 주입에 이용하는 생성자
    public Car(CarRepository carRepository) {
        this.carRepository = carRepository;
    }
}
```
2. 세터 주입 : 의존성은 세터 메서드를 통해 주입됩니다. 세터 주입은 선택적 의존성이 있거나 런타임(프로그램 실행 중)에 의존성을 수정하려는 경우에 유용합니다.
```java
@Service
public Class AppUserService {
    // 필드 정의
    private AppUserRepository userRepository;
        
    @AutoWired
    public void setAppUserRepository(AppUserRepository userRepository) {
        this.userRepository = userRepository;
    }
    // 이상의 코드 그냥 일반적인 setter라고 볼 수 있습니다. call2() 유형이죠.
    
    // 그러면 이제 userRepository를 이용한 다른 메서드들을 여기서 사용할 수 있죠.
    // 저희가 volumeUpButton을 이용했던 것처럼요.
    // userRepository.findAll();로 전체 목록을 불러와서, 전체 user 숫자를 카운트한다든지 등.
}
```

3. 필드 주입 : 의존성을 필드에 직접 주입합니다. 가장 단순하긴 한데, 의존성을 사용할 수 없는 경우에 런타임 에러가 발생할 수 있고,
   테스트를 위해서 모의 객체를 만드는 게 아니라 그때그때 새로운 객체가 만들어지기 때문에 테스트하기가 좀 어렵습니다.
```java
//필드 주입
@Service
public class CarDatabaseService implements CarService { 
    // 여기에 어쩌고 Car 데이터베이스 서비스가 있다고 가정하겠습니다.
}

public class CarController {
    private CarDatabaseService carDatabaseService = new CarDatabaseService();
    
    @Autowired                 // 여기가 좀 중요합니다.
    private CarDatabaseService carDatabaseService;
}
```

# JPA를 이용한 데이터베이스 생성 및 접근
Springboot와 함께 JPA(Jakarta Persistence API / Java Persistence API)를 이용하는 방법 및 Entity 클래스로 데이터베이스를 정의하는
방법을 학습하겠습니다(SQL로는 할 수 있었죠).

H2 인메모리 데이터베이스라는 개념을 학습할겁니다. 그리고 H2에서 MariaDB로 이동을 시킬겁니다. 동시에 CRUD Repository를 생성하고, 데이터베이스의
테이블과 엔티티 클래스의 관계에 대해 학습하겠습니다.

## ORM / JPA / Hibernate 개념
ORM / JPA는 RDB를 처리하기 위해 소프트웨어 개발에서 널리 이용되는 기술로, 복잡한 SQL 쿼리를 작성할 필요 없이 Java 개발자에게 친숙한 객체 형태로 DB를 
조작할 수 있습니다. ORM / JPA는 SQL 코드 작성 및 디버깅에 소요되는 시간을 줄여줍니다.

근데 우리는 Java는 좀 까먹었고 지난 금요일에 SQL 쳤으니까 SQL 도 까먹었겠네요.
대부분의 JPA 구현체들은 Java Entity 클래스를 바탕으로 DB의 스키마를 자동으로 생성할 수 있습니다.

1. ORM(Object Relational Mapping) : 객체지향 프로그래밍 패러다임을 이용하여 DB를 가져오고 매핑할 수 있는 기술.
   ORM은 데이터베이스 구조보다는 객체지향 개념을 바탕에 두고 있어서 Java 개발자가 굳이 SQL까지 배울 필요성을 줄여준다는 점에서 장점이 있습니다.
    그리고 장점은 ORM으로 개발하게 되면 DB와는 독립적으로 구동되기 때문에 개발자가 이용하는 DBMS가 무엇인지에 따라 달라지는 SQL문에 대해 걱정할
   필요가 없습니다. -> 즉 DB이식이 좀 쉽습니다.
2. JPA : Java 개발자를 위한 객체-관계형 매핑을 제공(ORM의 더 구체적인 버전이라고 생각하시면 됩니다.). JPA 엔터티는 데이터베이스 테이블의 구조를 나타내는
Java 클래스에 해당합니다. (이미 수업했습니다.) 엔티티 클래스의 필드는 데이터베이스 테이블의 Column을 나타냅니다.
3. Hibernate : 최근에 가장 인기있는 JPA 구현체이고, 스프링 부트에서 기본 구현체로 이용됩니다. 대규모 애플리케이션에서 자주 쓰입니다.

## 엔티티 클래스(Entity)
JPA에서 @Entity 애너테이션을 이용하는 Java 클래스로, 표준 Java bean 명명 규칙도 따르고, 적절한 getter/setter 메서드도 가집니다.
그리고 private으로 설정합니다.

얘는 애플리케이션이 초기화될 때 _클래스 이름으로 데이터베이스의 테이블을 생성_ 합니다. 만약에 다른 이름으로 지정하고 싶으면 엔티티 클래스에 @Table 애너테이션을 별개로
달 수 있는데, 이는 추후 수업하겠습니다.

그럼 알 수 있는 거 -> 
1. field 명이 column 명이 된다.
2. class 명이 table명이 된다.
3. 
```java

plugins {
id 'java'
id 'org.springframework.boot' version '3.5.6'
id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'
description = 'Demo project for Spring Boot'

java {
toolchain {
languageVersion = JavaLanguageVersion.of(17)
}
}

repositories {
mavenCentral()
}

dependencies {
implementation 'org.springframework.boot:spring-boot-starter-web'
developmentOnly 'org.springframework.boot:spring-boot-devtools'
testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

tasks.named('test') {
useJUnitPlatform()
}

```java
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    runtimeOnly 'com.h2database:h2'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```

```

1. @Id : DB에서의 테이블의 Primary Key에 해당하는 field에 달아주는 애너테이션(그럼 DB에서의 기본 키 개념을 명확히 아셔야겠네요.)
    2. @GeneratedValue : 데이터베이스가 자동으로 ID를 생성하도록 지정(ID값을 우리가 객체 생성할 때 일일이 넣지 않는다는 것을 의미합니다.
        다른 키 생성 전략을 사용할 수도 있습니다.) AuTO는 JPA 공급자가 특정 데이터베이스에 가장 적합한 전략을 선택한다는 의미로, default값입니다.

-DB에서의 column명은 기본적으로 클래스 필드 명명 규칙에 따라 지정됩니다. 그래서 다른 컬럼명으로 지정하고 싶다면 @Column 애너테이션을 활영하여 커스텀할 수도 있습니다.
 또한
3. @Column : 컬럼명을 사용자화 / 컬럼의 길이 / 컬럼의 nullab 여부를 지정하는 것도 가능합니다. 예시는 이하와 같습니다.
        ```java
@Entity
public class Car {
    @Id
    @GeneratedValue(strategy = Generation. Type.AUTO)
    private long id;

    @Column(name="explanation", nullable=false, length=512)
    private String description;
}
```
즉, Car 클래스의 description 필드는 car 테이블에서는 expl

```properties
spring.application.name=cardatabase
spring.datasource.url=jdbc:h2:mem:testdb
spring.jpa.show-sql=true
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
```
chrome에서 
localhost:8080/h2-console
이라고 접속하게 되면

이상까지의 상황에서 나타난 수강생 분들의 오류 모음
1. domain 패키지가 test 내에 있었던 경우에는 실행은 됐으나 sql문이 실행되지 않았습니다.
2. application.properties에서 오타가 있었습니다.
3. -이상의 경우들에서 생기는 문제점은 실행은 된다는 점, 근데 생각한 결과값이 콘솔에 안찍힘. 그래서 폴도 구조 신경써야함.


## CRUD repositiory 생성
Spring Data Jpa에는 CRUD작업을 위한 CrudRepository라는 인터페이스가 있습니다. 해당 인터페이스는 엔티티 클래스에 CRUD 기능을 제공합니다.

1. domain 패키지에 interface인 CarRepository를 생성.
```java
package com.example.cardatabase.domain;
    
import org.springframework.data.repository.CrudRepository;

public interface CarRepository extends CrudRepository<Car, LOng> {
    
}
```
CarRepository는 스프링부트 JPA의 CrudRepository 인터페이스를 바탕으로 확장된 클래스입니다(상속받았으니까 부모 클래스의 필드/메서드를 사용할 수 있죠. 근데
둘 다 인터페이스니까 추상 메서드들을 상속받았다고 볼 수 있겠음) 그리고 <Car, Long> 타입의 argument는 Car 엔티ㅣㅌ 클래스의 리포지토리이고, id 필드의 타입이 long임을 명시했습니다.
이상의 제네릭으로 인해서 Car-CarRepository 관계가 Entity-Repository 관계로 성립됩니다.

CrueRepository 인터페이스에는 당연히 추상 메서드들이 있을 겁니다. 일반적으로 사용되는 메서드 목록을 명시하겠습니다.

## CrudRepository의 추상 메서드 소개
1. long count() - 엔티티의 수를 반환 
2. Iterable<T> findAll() - 지정한 타입의 모든 항목을 반환                                              -Read
3. Optional<T> findById(ID id) - 지정한 ID의 한 항목을 반환(JS에서 getElementById() 생각하시면 됩니다)    -Read
4. void delete(T entity) - 엔티티 삭제                             -Delete
5. void deleteAll() -  리포지토리 내의 모든 엔티티를 삭제              -Delete
6. <S extends T> save(S entity) - 엔티티를 저장                     -Create
7. `List<S>` saveAll(`Iterable<S>` entities) - 여러 엔티티를 저장    -Create

method가 한 항목만 반환할 때는 T 대신에 `Optional<T>`를 반환합니다. Optional 클래스는 Java 8 SE에서 처음 도입된 타입으로, 값을 포함하거나
포함하지 않는 단일 값 컨테이너입니다.(특정 id값이 없는 경우에 보통 메서드 결과값이 오류로 발생하기 떄문에 이를 막는 용도로 Optional을 사용합니다.)
값이 있으면 isPresent() 메서드가 true를 반환하고, 없으면 false를 반환합니다. 그리고 값이 있을 때만 get() 메서드를 통해 값을 얻게 됩니다.

해당 Optional을 사용하게 되면 NullPointerException을 방지할 수 있습니다.

2. 이제 H2 인메모리에 예제 데이터들을 집어넣겠습니다. 인메모리 DB는 실행될 때마다 DB를 새로 만들고, 종료될 때 삭제하기 때문에 현재 h2-console에서 값을
    입력해봤자 껐다 키면 없어집니다. 이를 방지하기 위해서 Springboot 프로젝트 내에 예제 데이터를 집어넣도록 할 겁니다. 

CommandLineRunner 인터페이스를 사용 -> 애플리케이션이 완전히 시작되기 전에 특정 코드를 실행할 수 있음.
CarDatabaseApplication에 CommandLineRunner를 구현합니다. 

package com.example.cardatabase;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class CardatabaseApplication implements CommandLineRunner {
private static final Logger logger = LoggerFactory.getLogger(
CardatabaseApplication.class
);

	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
		logger.info("Application Started ! / 애플리케이션이 실행되었습니다.");
	}

	@Override
	public void run(String... args) throws Exception {
		
	}
}
```
```
다음, 새로운 Car 객체를 데이터베이스에 저장할 수 있도록 CarRepository를 main 클래스에 주입할겁니다. 
생성자 주입 개념을 통해서 CarRepository를 주입하겠습니다.