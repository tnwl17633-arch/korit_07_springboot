
# Spring Security 추가 정리
## 정의
-Spring 기반의 애플리케이션 보안(Authentication / Authorization)을 위한 표준 프레임워크. 서블릿 필터(Servlet Filter) 체인을 기반으로 동작하며, 웹 요청에 대한 보안을 체계적으로 처리함. 단순한 로그인 기능 뿐만 아니라, CSRF 공격 방지, 세션 관리, 권한 기반 접근 제어 등 포괄적인 보안 기능을 제공.

## 특징
1. 포괄적 보안 기능 : 인증(Authentication) / 인가(Authorization) 뿐 아니라 일반적인 웹 보안 위협으로부터 애플리케이션을 보호
2. 유연한 설정 : Java 기반의 설정을 통해 유연하게 보안 정책을 설정할 수 있음(우리가 해야한다는 뜻)
3. 서블릿 필터 기반 : 요청이 컨트롤러에 도달하기 전에 여러 보안 필터를 거치게 하여 선제적인 보안 검사를 수행.
4. SpringBoot와의 통합 : `spring-boot-starter-security` 의존성만 추가하면 기본적인 보안 기능이 자동 설정되어 빠르게 적용 가능(default 로그인 페이지가 생겼고, password가 콘솔에 찍혔습니다).

## SecurityConfig
-Spring Security의 보안 구성(Config)을 담당하는 Java 설정 클래스로, 해당 클래스에는 `@Configuration, @EnableWebSecurity` 애너테이션을 추가하여 Spring Security의 웹 보안 설정을 활성화하고 커스터마이징 할 수 있습니다.

-과거에는 `WebSecurityConfigurerAdapter`를 상속받아서 configure() 메서드를 오버라이딩하는 방식으로 사용했었지만, SpringBoot 3.x 버전부터는 SecurityFilterChain 빈(bean)을 등록하는 방식이 권장됩니다.
현재의 방식은 컴포넌트 기반의 구성으로, 더욱 모듈화되고 유연한 보안 구성이 가능합니다.

### SecurityConfig의 핵심 역할
1. HTTP 요청에 대한 접근 제어 : 특정 URL 패턴에 대해 인증된 사용자만 접근을 허용하거나, 특정 권한(Role)을 가진 사용자만 접근 가능하도록 설정 가능.
2. 인증 방식 설정 : 폼 로그인(Form Login), HTTP Basic 인증, OAuth2 로그인 등 다양한 인증 방식을 설정하고 커스터마이징 가능.
3. 로그아웃 처리 : 로그아웃 URL 및 로그아웃 성공 후 처리 로직을 정의.
4. 비밀번호 암호화 : `PasswordEncoder`를 빈으로 등록하여 사용자의 비밀번호를 안전하게 암호화하고 검증하는 방식을 지정.
5. CSRF, CORS 설정 : CSRF 보호 기능을 활성화하거나 비활성화하고, CORS 정책을 구성합니다.

### SecurityConfig 코드 예시
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
  // 비밀 번호 등록을 위한 PasswordEncoder 빈을 등록
  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCyptPasswordEncoder();
  }

  // Spring Security의 filterChain을 작성할겁니다.
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http.
    // 1. 인가(Authorization) 구성
      .authorizeHttpRequests(authorize -> authorize
      .requestMatchers("/users/**").authenticated() // /user/** 경로는 인증된 user만 가능
      .requestMatchers("/manager/**").hasRole("AUDMIN", "MANAGER") // /manager/** 경로는 role이 ADMIN이거나 MANAGER인 user만 가능
      .requestMatchers("/admin/**").hasRole("ADMIN") // /admin/** 경로는 role이 ADMIN인 user만 가능
      .anyRequest().permitAll() // 나머지 경로에 대한 요청들은 접근을 허용함.
      )
      // 2. 폼 로그인(Form Login) 구성
      .formLogin(form -> form
        .loginPage("/login")   // 커스텀 로그인 페이지의 URL 지정
        .loginProcessingUrl("/loginProc") // 로그인 처리 URL
        .defaultSuccessUrl("/") // 로그인 성공 시 이동할 default URL
        .permitAll()          // 로그인 페이지는 모든 사용자가 접근 가능
      )
      // 3. 로그아웃 설정
      .logout(logout -> logout
        .logoutUrl("/logout") // 로그아웃 처리 URL
        .logoutSuccessUrl("/")  // 로그아웃 성공시 이동할 URL
        .invalidateHttpSession(true)   // 세션 무효화
        .deleteCookies("JSESIONID")      // 쿠키 삭제
      )
      // 4. CSRF 보호 비활성화(API 서버의 경우)
      .csrf(csrf -> csrf.disable());
  }
}
```
-이상의 코드의 상세 설명
  1. authorizeHttpRequests : HTTP 요청에 대한 인가 규칙을 구성
    -requestMatchers() : 특정 URL 패턴을 지정
    -authenticated() : 인증된 사용자만 접근 허용
    - hasAnyRole(), hasRole() : 특정 역할을 가진 사용자만 접근을 허용. Spring Security에서 역할(Role)은 기본적으로 "ROLE_" 접두사가 붙어서 처리됩니다.(예시 : hasRole("ADMIN")은 "ROLE_ADMIN" 역할을 확인한다는 의미입니다)
    -permitAll() : 모든 사용자의 접근을 허용.
    -anyRequest() : 위에서 설정한 규칙 외의 모든 요청을 의미함. 그래서 인가 규칙의 경우 구체적인 경로를 먼저 구성하고, 포괄적인 경로는 나중에 구성해야 합니다._ 
  2. formLogin : 폼 기반 로그인을 설정
    -loginPage() : 기본 제공되는 로그인 페이지 대신 사용할 커스텀 로그인 페이지의 경로를 지정.
    -loginProcessingUrl() : 로그인 폼 데이터를 처리할 URL을 지정. 이 URL에 대한 POST 요청을 Spring Security가 가로채서 인증을 처리함.
    -defaultSuccessUrl() : 로그인 성공 후 사용자를 리디렉션할 기본 페이지 지정.
  3. logout : 로그아웃 관련 설정.
    -logouturl() : 로그아웃을 처리할 URL을 지정.
    -logoutSuccessUrl() : 로그아웃 성공 후 리디렉션 될 페이지를 지정.
    -invalidateHttpSession(true) : 로그아웃 시 HTTP 세션을 무효화.
    -deleteCookies("JSESSIONID") : 로그아웃 시 지정된 쿠키를 삭제.
   4. csrf(csrf -> csrf.disable()) : CSRF 보호 기능을 비활성화. 세션 기반 인증이 아니라 _JWT와 같은 토큰 기반 인증을 사용하는 API 서버의 경우 일반적으로 비활성화_ 

   Java 관련 visual studio code Extension

   Code Runner -> Java 프로젝트를 실행시키려면 필요합니다.
   Debugger for Java
   Extension Pack for Java

   # 현재까지의 상황을 바타옹르 한 다음 단계 생각해보겠습니다.
   AppUser / AppUserRepository를 생성함으로써 DB에 AppUser 관련 테이블이 생성됐고, Spring Security 의존성을 도입하여 default login이 가능합니다.

   이제 보안 관련 로직을 현재 프로젝트의 MVC 패턴에 맞게 설정할 필요가 있겠습니다.

   1. 사용자 인증을 위한 Service 계층 구현. : Spring Security가 데이터베이스의 사용자 정보를 기반으로 인증을 수행할 수 있도록 UserDetailsService를 구현할겁니다.
    -Service 패키지 내에 UserDetailsServiceImpl 클래스를 생성하고 UserDetailsService를 _구현_ 하세요.

```java
package com.example.cardatabase_4.service;


import com.example.cardatabase_4.domain.AppUser;
import com.example.cardatabase_4.domain.AppUserRepository;
import org.springframework.security.core.userdetails.User.UserBuilder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;

import java.util.Optional;

import static org.springframework.security.core.userdetails.User.withUsername;


public class UserDetailsServiceImpl implements UserDetailsService{
    private final AppUserRepository appUserRepository;
    
    public UserDetailsServiceImpl(AppUserRepository appUserRepository) {
        this.appUserRepository = appUserRepository;
    }


    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<AppUser> user = appUserRepository.findByUsername(username);

        UserBuilder builder = null;
        if(user.isPresent()) {
            AppUser currentUser = user.get();   // user 자체는 Optional 자료형이지 AppUser가 아닙니다.
            builder = withUsername(username);
            builder.password(currentUser.getPassword());
            builder.password(currentUser.getPassword()).roles(currentUser.getRole());
        } else {
            throw new UsernameNotFoundException("User Not Found.");
        }
        
        return builder.build();
    }
}

```
이상의 코드는 cardatabase_2의 UserDetailsServiceImpl과 코드라인이 일부 변경되었습니다. 그 과정 중에서 AppUserRepository의 내부에 findByUsername(String username) 추상 메서드를 정의했는데, 일반적인 방법으로 한 것이 아니라 오류를 발생시킨 다음에 intellij의 내부 기능을 사용하여 자동 생성을 했었습니다.

또한 User 클래스를 가지고 온 것이 아니라 static 메서드를 import 하는 방식으로 코드라인을 줄였습니다.

builder을 가지고 온 김에 chaining method를 도입하여 builder 객체를 생성했었습니다.

2. JWT 토큰 생성 및 검증 Service 구현 : 로그인 성공 시에 JWT 토큰을 발급하고, 이후의 모든 요청에서 토큰을 검증하는 JwtService를 만듭니다.
  -관련 의존성을 추가하고,
  -service 패키지에 JwtService 클래스를 생성하세요.

3. 로그인 Controller 및 관련 클래스 생성 : 로그인 요청 시에는 ID와 비밀번호를 담을겁니다. 그러니까 이게 꼭 AppUser Entity가 아니겠죠. 그 때 우리는 뭘 새로 하나 만들었었습니다.
-domain 패키지 내에 AccountCredentials라고 하는 Record를 만드세요. 
-web 패키지에 LoginController 생성.

4. JWT 인증 필터 및 예외 처리 구현 : `/login`을 제외한 모든 API 요청을 가로채서 JWT 토큰의 유효성을 감시하는 Filter를 만들겁니다.

  -루트 프로젝트 패키지에 AuthenticationFilter 클래스를 생성하세요.
5. -AuthEntryPoint(인증 실패 처리) : 로그인 실패시에 현재대로라면 403이 떠야합니다(근데 저희 cardatabase4에는 아직 SecurityConfig가 없어서 실행도 안됩니다) 이 부분을 401 처리를 하기 위한 부분입니다.
- 루트 프로젝트 패키지에 AuthEntryPoint 클래스를 생성하세요.

6. 이상까지의 상황을 반영한 SecurityConfig를 작성.
-루트 프로젝트 패키지에 SecurityConfig 클래스 생성.

이상까지 작성했을 때 cardatabase_2와 좀 다른 부분들이 있는데 보편적으로는 JwtService 시작시점에 `@Service / @Component`의 차이입니다. 컴포넌트 애너테이션은 클래스 자체를 bean 등록하기 위한 것이라고 이미 설명했습니다. 서비스 애너테이션을 ctrl + 클릭 해보면 애초에 서비스 애너테이션이 컴포넌트 애너테이션을 상속받았음을 확인할 수 있습니다. 동일한 방식으로 `@RestController`도 ctlr + 클릭 하면 `@Controller`를 상속받았고, 또 얘를 클릭하면 내부에 `@Component`가 있음을 확인할 수 있습니다. 그러면 어차피 특정 클래스는 특정 역할을 한다고 애너테이션 명시를 하는 순간 `@Component`가 적용된다고 볼 수 있겠습니다. 

7. 현재 AppUser를 객체 추가하려면 SQL문을 통하거나 혹은 CommandLineRunner를 통해서 해야할 것 같습니다.
이를 통해 생성된 AppUser 객체를 가지고 로그인 성공 시 / 실패 시를 확인하면 spring-data-rest 없는 상태의 부분이 구현될 것 같습니다.(저는 Owner가 없는 상태긴 합니다).

# 시험 예시 문제
온라인 서점에서 판매할 일반 도서(Book)와 전자책(EBook)을 관리하는 시스템을 구축하려고 합니다. Book 클래스를 상속받는 EBook 클래스를 완성하고, 각 클래스의 객체를 생성하여 정보를 출력하는 프로그램을 작성하시오.

요구사항 명세서 : 
1. Book 클래스는 title(제목)과 author(저자)를 필드로 가집니다.

2, EBook 클래스는 Book 클래스를 상속받으며, fileSize(파일 크기) 필드를 추가로 가집니다.

3. 각 클래스는 필드 정보를 출력하는 displayInfo() 메서드를 가집니다. EBook 클래스의 displayInfo()는 Book의 메서드를 오버라이딩하여 파일 크기 정보가지 함께 출력해야합니다.

4. main 메서드에서 Book과 EBook 객체를 각각 생성하고, displayInfo() 메서드를 호출하여 아래 "실행 예"와 같이 출력되도록 코드를 완성하세요.

실행 예
제목: 자바의 정석, 저자: 남궁성
제목: 스프링부트 3 백과사전, 저자: 김영한, 파일 크기: 20.5MB

를 python으로 전부 snake_case로 바꿔서 작성하시오.

```java
public class Book {}

public class EBook extends Book {}

public class BookMain{
public static void main(String[] args) {

  }
}
```


```python
class Book:
  pass
  class EBook(Book):
    pass

```


**설명**
동물(`Animal`) 클래스와 이를 상속받는 개(`Dog`), 고양이(`Cat`) 클래스를 통해 **다형성**을 구현합니다. 업캐스팅된 객체를 다루고, 필요한 경우 다운캐스팅하여 자식 클래스 고유의 메서드를 호출하는 프로그램을 작성하시오.

**요구사항 명세서:**

1. `makeSound()` 메서드를 가진 `Animal` 클래스를 만듭니다.
2. `Animal`을 상속하고 `makeSound()`를 오버라이딩하는 `Dog`와 `Cat` 클래스를 만듭니다.
3. `Dog` 클래스에는 고유 메서드인 `fetch()`를 추가합니다.
4. `Animal` 타입의 배열 `animals`에 `Dog`와 `Cat` 객체를 업캐스팅하여 저장합니다.
5. 반복문을 통해 배열의 모든 동물이 각자의 소리를 내도록 `makeSound()`를 호출합니다.
6. `instanceof` 연산자로 `Dog` 객체를 확인한 후, **다운캐스팅**하여 `fetch()` 메서드를 호출합니다.

**제공된 코드**

```java
class Animal {
  public void makeSound() {
    System.out.println("동물이 소리를 냅니다.");
  }
}

class Dog extends Animal {
  @Override
  public void makeSound() { /* TODO: "멍멍!"출력 */}
  public void fetch() {/* TODO: "공을 가져옵니다." 출력 */}
} 

class Cat extends Animal {
  @Override
  public void makeSound() {/* TODO: "야옹~" 출력 */}
}

public class PolymoraphismExample {
  public static void main(String[] args) {
    Animal[] animals = new Animal[2];
    // TODO: animals 배열의 0번 인덱스에 Dog 객체를, 1번 인덱스에 Cat 객체를 할당하시오.
    // TODO: 반복문을 사용하여 모든 동물의 makeSound() 메서드를 호출하시오.
    // 추가로, instanceof를 사용해 Dog일 경우 다운캐스팅하여 fetch() 메서드를 호출하시오.
  }
}
```

